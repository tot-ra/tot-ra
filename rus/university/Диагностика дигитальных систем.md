вторник, 9 января 2007 г. в 21:42:11

### О предмете

Диагностика в целом это не наука, это философия, т.е. присущая многим дисциплинам методология. Диагностика занимается анализом системы, обнаружением ошибок, процессов, их причин и их местонахождением. Применимо к дигитальным системам, т.е. фактически к электронным цепям построенным по булевой двоичной логике на транзисторных микросхемах, диагностика занимается

- развитием теоретической части с применением всевозможных теорий графов и математического аппарата
- созданием алгоритмов для автоматической проверки микросхемы программно, поскольку  в современный век непрактично более проверять вручную схему, выпускающуюся на конвейре

В Таллиннском Техническом Университете лектор по этому предмету ([IAF0050](http://ati.ttu.ee/index.php?page=4110&aine=IAF0050)) - Раймонд Убар, подошедший хорошо с теоретической и материальной частью к образованию, поскольку всё доступно из сети:

- [Слайды](http://www.pld.ttu.ee/%7Eraiub/web_0103/diagnostika/loengukiled/) на английском языке
- Три лабораторных
- Сложнейшая [домашняя работа](http://www.pld.ttu.ee/info/dd/dd_ylesanne_01.html)

---

### Лабораторные работы

Первая называется **Test generation** и состоит в практике генерировать вручную и программно векторы (сигналы на входах) так, чтобы те покрывали все возможные ошибки в схеме. Лабораторная разделяется на три части, по схемам - [достаточно простая](http://www.pld.ttu.ee/testing/labs/small.html) (вариант которой вы получаете [в задании](http://edu.pld.ttu.ee/)), где необходимо ввести вручную 14 векторов взяв их с потолка и добиться 100% покрытия ошибок, потом алгоритмически смотря на схему, добиться значительно лучшего результата (см. ниже).  
  
Работа может происходить как на Sun-ах с Open Windows оболочкой, так и с Common Desktop Enviroment, так и на простой Windows 98/XP/...  
Для Windows тогда необходимо скачать пакет программ Turbo Tester чтобы практиковаться дома. На лабораторных же все программы уже встроены и можно сразу вводить комманды.  
  
Для работы с первым заданием достаточно сохранить source-файл с расширением **agm** к себе в папку и открыть его коммандой **vecmanager**. Далее вводим векторы и проводим fault simulation. Смотрим сколько покрыто ошибок и т.д.  
  
Второе задание посложней, схема представляет собой "full 8-bit ripple-carry adder" и состоит в том что-бы сопоставить техники автоматического выбора векторов а также алгоритмически выбрать некоторые вектора (см. ниже).. Автоматический подбор осуществляется коммандами generate, random, genetic. Время генерации и число векторов и надо сопоставить.  
  
Третья схема ещё сложней, но по сути - самая лёгкая. Для неё надо выпонить те же три комманды, получить статистику и посчитать "цену" для каждой процедуры.. Genetic всегда получается самой дешёвой например. Альфа =1 , Beta=0.1 Gamma=10 кажись.  
  
  
Теперь об алгоритмическом решении первой схемы.. Как говорят лекции и англоязычная документация лабораторной, у нас есть простая комбинационная схема из AND, OR, NAND, NOR, NOT элементов. Нам необходимо проверить схему на наличие неисправностей. Предполагаем что неисправности ограничиваются поломками соединений так, что возможные ошибки это константа ноль ( =0 ) и константа единица ( =1 ). Теперь чтобы проверить все соединения, будем проверять соединения не по одиночке, а соединения при логических элементах. Легко видеть, что элементы с двумя входами AND, NAND, OR, NOR полностью проверяются на наличие неисправностей тремя векторами во всех соединениях. Элементы с тремя входами нуждаются в четырёх векторах.  
  
Проверка всей схемы начинается с проверки самого правого элемента (или одного из них). Ставим на него нужные три проверочных вектора и логически следим, какие сигналы нужны для этого на входе. Так получаем предполагаемые нужные вектора. По мере слежения, может возникнуть ситуация конфликта где на одном разветвлении соединения должна идти единица, а на другом - ноль.. Также по мере слежения, вектора на входе получаются в несовсем определённом виде.. скажем некоторые входы могут иметь любое значение, некоторые можно выбрать в зависимости от других и тп. С такими ситуациями надо разбираться глядя уже на левые элементы схемы.  
  
В итоге мы должны получить покрытие для всех элементов с **прозрачностью** следующих за ними, т.е. наличие ошибки в конкретном элементе должно наблюдаться на выходе схемы (т.е. не прерываться логикой элементов следующих за исследуемым)

Алгоритмическое решение второго задания.  
Каждый сумматор состоит из двоичных элементарных сумматоров, где на входе a0 , b0 - двочные разряды которые надо сложить и c0 - значение переноса с предыдущего сумматора. Имея 8 подобных сумматоров и выстроив их один за другим, нарисуем табличку

|   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|
|c0|a0|b0|c1|a1|b1|c2|
|0|0|0|0|0|0|0|
|0|0|1|0|0|1|0|
|0|1|0|0|1|0|0|
|0|1|1|1|0|0|0|
|1|0|0|0|1|1|1|
|1|0|1|1|0|1|1|
|1|1|0|1|1|0|1|
|1|1|1|1|1|1|1|

в каждом блоке сумматор проверяется на все 8 возможных значений со входа, которые дальше передаются в следующий сумматор.. так мы проверяем весь сумматор сохраняя число нужных векторов для проверки элементарного сумматора. Достигается это чередованием 4 и 5го векторов.. Заметьте что значение c1 зависит от значений предыдущих c0, a0, b0.  
  
Получив в результате таблицу для 8ми сумматоров, открываем vecmanager, и видим что он хочет вектор в виде  
Cin b7 a7 ...  
Поэтому все эти значения (Cin - в нашем случае c0) получаем из таблички. Таким образом 8 векторов (длинной в 17 бит) покрывают 100% ошибок, о чём и должен со счастьем сообщить vecmanager после ввода и симуляции.

Вторая лабораторная.  
Получив и сохранив схему (в моём случае, d4), написав комманды

`xtimport -paths -tool cadence d4.edi ams.lib   xtimport -spec -tool cadence d4.edi ams.lib   generate d4   prediag d4`

мы задали в результирующей схеме некую ошибку в одном элементе, т.е. считается что один из элементов схемы ведёт себя по-другому, причём он может быть один из NOR, NAND, OR или AND.  
Задача тестирования в первой лабе сводилась к получения ответа на вопрос "есть ли ошибка?", теперь же вопрос стоит "где находится ошибка?". После введения последней комманды prediag, мы получаем элементы подозрительные на наличие этой ошибки.  
Вопрос - как обнаружить какой из них ошибочный и какой ошибочный в действительности в данном случае самый главный. Легко заметить, что все подозрительные элементы группируются на ветке одного из выходов. Легко заметить что последний элемент в этой ветке как правило тоже подозрителен.  
По тому как я разбирался в алгоритме, я примерно понял, что алгоритмов несколько, или хотябы каждый понимает его по-своему и объяснить в обобществлённой форме этого неможет. К примеру есть вариант где идёт разбиение элементов на группы по принципу "что влияет на OK на выходе и что невлияет", после чего идёт выявление подозреваемой группы.  
Мой вариант, возможно неправильный, возможно идентичный тому что выше, но сводится примерно к 3-5 векторам или более.. Основан на таблицах истинности элементов.  
Берём самый последний элемент в ветке, который у самого Y стоит.. Тестируем его на три-четыре вектора 00, 01, 11, 10. Последний не очень обязателен, но всё же.. То как вы эти векторы получите в самом начале, уже другая история, но главное это проползти так чтобы конфликтов не получилось. Протестировав эти векторы, мы обязательно получим ошибку.. Скажем ошибка будет на 00, а элемент этот последний - OR, это значит..  
Последний OR элемент:  
A B Q  
0 0 0 <-тут выдалось ERR  
0 1 1  
1 0 1  
1 1 1  
  
Поскольку Error на первой комбинации, то на выходе схемы вместо нуля мы получили единицу из-за ошибки какого-то элемента. Это значит что либо этот самый последний OR элемент ведёт себя так что на выходе всегда даёт единицу, что мы исключаем по условию, либо ошибка затаилась где-то раньше.  
Таким образом мы вычёркиваем последний элемент.  
  
Во время создания этого условия чтобы на этот OR поступили именно такие векторы, мы в некоторых случаях вольны выбирать любые значения на некоторых элементах. Имеет смысл выбирать их как можно разнообразней.  
Когда у вас имеется 4 вектора, то может легко получиться что остальные элементы тоже прошли все возможные комбинации 00,01,10,11 как вышеназванный OR.  
  
Вычеркнув последний элемент из списка подозреваемых, движемся глубже в схему..  
Можем набрести на  
NOT  
A Q  
1 0  
0 1 ->ERR  
0 1 ->OK  
Легко понять, что этот элемент впорядке, поскольку если бы он работал ненормально, то место OK была бы тоже ERR.  
  
Ещё пример OR:  
A B Q  
0 0 0 ->OK  
0 1 1 ->OK  
1 0 1 ->ERR  
1 1 1 ->OK  
Очевидно, что OR не может вести себя как сложная смесь XOR и AND, впрочем я уверен что для него имеется своё название, но суть в том, что в множестве допустимых вариантов AND,NAND и NOR, он ни к чему не подходит, поэтому он в порядке.  
  
Ну и что-бы не вводить в заблуждение что все элементы так уж вычёркиваются, привожу свой ошибочный элемент.. AND  
A B Q  
1 1 1  
1 0 0 ->ERR  
0 0 0  
Так уж получилось, что два раза вектора совпали, что не дало всех вариантов, но видно, что AND очень уж стремится стать OR-ом.  
Задав ещё один, пятый вектор, получил подтверждение, что  
0 1 ->ERR  
что и дало подтвердило мои подозрения. Удачи.

### Домашняя работа

В качестве объекта выбирается микросхема, реализующая простую комбинационную схему, т.е. схема имеющая множество входов X, логические элементы AND, OR, NOT и выход Y.  Функция для каждого учащегося своя, очевидно что-бы никто не списал.

1. Необходимо составить функцию с которой будет вся работа идти.
2. Нарисовать функцию в схематическом редакторе Cadence, на Solaris-платформе (установлены в IT-корпусе). Использовать надо элементы из HRDLIB библиотеки, причём при создании схемы каждое отрицание над элементом в функции означает обязательный элемент отрицания в схеме. Открываем файл .cshrc и раскомментирываем там строчки  
    `setenv DFW_97a   setenv AMS   setenv DFWII`  
    создаём каталог под домашнюю работу, и там вводим комманду  
      
    `ams_cds -tech csx -mode ds`  
    она видимо подготавливает и вываливает в каталог кучу файлов.  
    Дальше прогу можно запускать просто ams_cds коммандой. Cadence запустилась, открываем из меню New Lib. Называем, выбираем don't need...  
    Потом создаём новую схему из меню New Cell View.  
    Далее разбираемся, ставим входы (красненькие) x1, x2.. x6 , инверторы и прочие логические элементы можно поставить из HARDLIB (называются они соотв. OR22, NA22..). Схему составляем по заданным формулам, в итоге в конце получаем выходы y1, y6 (это для моего случая), их надо объединить элементом OR и сделать один выход Y.
3. Решить дифференциальное уравнение ?Y/?xk, где xk - некий фиксированный номер/элемент. Зачем? Показать насколько сложно и непрактично создавать тест-вектор таким методом.  
      
    Мысль заключается в том что если в математике дифференциал означает скорость изменения функции на участке бесконечно малом и близком к x, то на дискретном пространстве дифференциал означает изменение функции при изменении входа, а функцию изменения входа можно представить как XOR той же функции но с разным значением дифференцируемого входа (XOR=1 если функции различны) :  
    ?Y/?xk = Y(xk=0)?Y(xk=1)  
      
    Теперь используя теорию, принимаем что функция Y зависит от xk и любое изменение xk отобразится на значении Y, т.е. ?Y/?xk = 1. Решаем это уравнение и находим все остальные X, которые могут быть и неопределёнными, в итоге получаем тест-вектор, или же возможно что тест вектор получить неполучится, что в свою очередь значит что ?Y/?xk = 0, т.е. этот элемент нетестируем.
4. Создать Structurally Synthesized Binary Decision Diagramm по главной функции Y, который представляет из себя граф, в котором  
    
    - Вершины это входы в конкретный элемент и нумеруются в зависимости от входа в схему, т.е. если в формуле был блок x1(x3+x1)x2x3 ,то для структурного графа это представляет из себя x**11**(x31+x**12**)x21x32
    - Движение по вершинам слева направо означает AND-логику и ведёт к 1
    - Движение вниз по вершинам означает OR-логику и ведёт к 0
    
    Смотрите слайды что-бы понять логику как они создаются. Это основной граф для работы в дальнейшем над тестированием неисправностей на конкретных элементах  
    
5. Binary Decision Diagramm не учитывает структуры схемы и она используется только для тестирования входов. Создаётся BDD по достаточно простому принципу разложения Шеннона, например:  
    Y=x1+x2x3=x2(x1+x3)+!x2(x1+x3)
6. Сгенерировать тест-вектора для всех элементов из Y. Используется SSBDD, полученная в задании 4. См. слайды что-бы понять как конкретно происходит path-activation и fault propagation для SSBDD. Для тестирования элемента на constant 0 выбирается конкретный элемент и по графу выбирается такой путь вправо (к y=1), что-бы он проходил через выбранный элемент. Выбранный путь и есть вектор, однако что-бы элемент был тестируем, надо сделать доступным и альтернативный путь вниз (к y=0). Для того что-бы протестировать все элементы таким образом надо проделать достаточно большую работу по созданию графов с активацией обоих путей (как в обычной ситуации, так и для ошибочной версии) для всех элементов.  
    В итоге задания получается таблица вида  
    
    |   |   |
    |---|---|
    ||элементы (x11 x12 x13 x21..)|
    |векторы|проверяемые неисправности  <br>( =0 =1 X X X )|
    
7. Сгенерировать тесты, обнаруживающие неисправность, вызванную замыканиями парой входов. Принцип - при замыкании входов где 0 и 1 в итоге на обоих будет сигнал 0.
8. Сгенерировать тесты, обнаруживающие неправильный дизайн схемы из-за которого появляются задержки.
9. Протестировать заданные вектора и указать какие ошибки они тестируют
10. Вбить полученную в 6м пункте табличку с векторами в vecmanager и получить на сколько тестируется схема согласно cadence. До этого надо из cadence экспортировать схему в EDIF 2.0.0 из основного меню.  
    Помимо правильных полей дизайна, ещё должны быть  
      
    `external libraries: HRDLIB   design name: название дизайна, любое, хоть свой матриклинумбер   output file: imjafaila.edi   output format: Netlist   Netlist format: FLAT`  
    затем, лезем в консоль и пишем:  
    xtimport -paths -tool cadence imjafaila.edi ams.lib  
    xtimport -spec -tool cadence imjafaila.edi ams.lib  
      
    в принципе, можно попробовать указать оба ключа - и paths и spec одновременно, но у некоторых личностей такой способ не сработал - требовалось отдельно две строчки.  
      
    эти две команды создадут 3 файла:  
    imjafaila.agm, imjafaila.pat, imjafaila.spec
11. задача в том что.. допустим вектор 1 и 2 говорят что y ошибочен, а все остальные векторы говорят что всё в порядке. смотрим на таблицу открываемых ошибок этими векторами..  
    например таблица неисправностей выглядит так..  
    10XXXX11100011  
    X1XXX10XXX1XX  
    111XX1XXXXXXX  
      
    объединяем первый и второй вектора и получаем  
    1&XXX1&110&011  
    (поскольку неисправности 1 и 0 одновременно не могут быть на одном и том же элементе)  
    теперь сравниваем полученную строку с остальными векторами, получаем  
    &&XXX&&110&011  
    где & значит что на этом элементе ошибки быть не может  
    X значит что элемент не тестируется  
    1 или 0 значит что на этом элементе есть подозрение.  
      
    В итоге цель задания - обнаружение элемента на котором ошибка имеется, т.е. получение диагноза. Могут быть как несколько элементов, так и вообще не иметься.  
    

Что-бы работать удалённо - из дома делается ssh соединение и дальше (согласно Юре Богданову) из линукса консоль выглядит примерно так  

`westvleteren:/home/tXXXXXX>mkdir testcad10   westvleteren:/home/tXXXXXX>cd testcad10/   Directory: /home/tXXXXXX/testcad10   /home/tXXXXXX/testcad10   westvleteren:/home/tXXXXXX/testcad10>cad   Select your CAD tools:      1) MENTOR 2010 version   2) MENTOR 2004 version   3) SYNOPSYS 2010 version   4) CADENCE 2002 & SYNOPSYS   5) XILINX ISE 12.2   6) XILINX ISE 10.1.3   7) MENTOR 2007 version   8) CADENCE 2005 version   9) CADENCE 08/09 version   0) CADENCE 2009/2010 IC/SYS combined with AMS designkit v3.70   q) no selection      ----> 0         Environment ready for Cadence 2009/2010.      westvleteren:/home/tXXXXXX/testcad10>ams_cds -mode fb -tech cxq   [1] 7998   icfb : HIT-Kit=3.70 tech=cxq`

Что-бы распечатать нарисованную схему надо экспортировать схему в PS формат. Для этого надо

1. открыть Design->Plot->Submit.
2. убрать header->Plot
3. установить Options landscape
4. center plot
5. fit to page
6. send plot only to file: imjafaila.ps
7. убрать mail log to

перевести ps в pdf можно коммандой в консоли  
`ps2pdf imjafaila.ps`

### Экзамен

Вариант Антона.. 

1. genereerida diagnostikapuu antud rikketabelile  
    Таблица представлена действительно в виде таблицы, мне же лень вырисовывать, поэтому напишу так:  
    всего 9 нарушений и 4 вектора. единицы расположены так:  
    T1: 1, 4, 5, 9  
    T2: 2, 4, 7, 8  
    T3: 5, 6, 7, 9  
    T4: 1, 3, 4, 6, 7
2. дана схема (см рисунок). задание: genereerida kaks testvektorit kahe boole'i v?rrandis?steemi dy1/dz1 = 1 ja dy1/dz2 = 1 lahendamise teel, kasutades ahelv?rrandis?steemi lahendamise meetodit.
3. teoreetiline kysimus: testide genereerimine mikroprotsessoritele.

Вариант Дана.. 

1. Транизсторная схема + вероятность закорачивания в двух местах (ЭФ). Найти тествектор который выявляет ЭФ.
2. генерация теста по методу DNF
3. Sequuential Fault Diagnosis

Вариант Вадима

1. поставить диагноз маленькому уравнениею используя Булев полный дифференциал.
2. по данному уравнению составить бинарную диаграмму и найти на входе х3 константные ошибки
3. представление операционного автомата с помощью отсустус диаграмм 

Мой вариант..

1. Нарисовать SSBDD по формуле и протестировать с её помощью один из элементов.  
    
2. Дана схема и два вектора. Написать на что они тестируют элементы.. т.е. нарисовать табличку.
3. Теоретический вопрос (там было порядка 15ти), мне попался первый - полное дифференциальное уравнение, обнаружение ошибки.  
    

  
Потом посмотрел домашку, я чуток порассказывал. Поспрашивал что значат hhlhlhH в таблице, которую vecmanager выдаёт и почему некоторые буквы большие (я про фронты начал говорить, а это просто ноль и единица на входах и на выходе). Потом на задании 2 показал два провода - допустим тут замыкание, как это протестировать. Я то помнил что надо разные значения кидать, но думал что единица будет ноль перезаписывать, но когда high(1) и земля(0), то всё в землю уходит и на обоих будут нули.