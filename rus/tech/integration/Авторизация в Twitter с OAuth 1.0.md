четверг, 9 сентября 2010 г. в 22:57:33

Твиттер (а также Yahoo, Google, Facebook и LinkedIn ) штоб-его-заногу перешёл на безопасный [OAuth](http://oauth.net/) и я вспомнил как в своё время с матюгами несколько дней ставил серверную часть [OpenID](http://kurapov.name/rus/technology/web/openid/) на сайт. А они ведь похожи (авторам нравится буковка О, ага). Вобщем - как это работает? Если раньше был пользователь и твиттер, а мы со своим приложением _притворялись_ пользователем используя его логин-пароль, то теперь чётко выделяются три лица

- пользователь со своим браузером (**client**)
- мы-разработчики со своим сайтом или desktop-приложением (**consumer**)
- Твиттер предоставляющий всякие услуги (**service provider**)

---

Про [desktop-приложения уже говорили](http://www.liveinternet.ru/users/flashr/post133881520/), я расскажу только для сайта с php. В ходе обмена данными между собой используются три пары ключей (**tokens** = markers) которые на уровне библиотеки по хитрому алгоритму HMAC-SHA1 делают подпись (signature) и всё это компонуют в base64 для обмена. Значит существуют:  

- Ключ приложения (consumer key + secret) - нужен для нашей уникальности consumer'а  
    
- Ключ запроса (request token + secret) - временный; аналог сессии между приложением и твиттером  
    
- **Ключ доступа** (access token + secret) - постоянный для приложения, подобно "логин-паролю" и действует покуда пользователь у себя не запретит этот полу-аккаунт третьей стороны (т.е. нас)

![](img/Pasted%20image%2020241020021138.png)

### Процесс

1. Идём [регим приложение](https://twitter.com/oauth_clients) в твиттере, где указываем Callback URL (собственно где приложение находится) и получаем первый ключ (**consumer_key** + **secret**)  
    
2. Скачиваем, распаковываем и ставим оффициально признанную библиотеку [twitteroauth](http://github.com/abraham/twitteroauth), ставим в config вышеупомянутые два параметра
3. Теперь если запустить index.php, то выполняется описанный в диаграмме процесс начальной связки пользователя с приложением. Это никак не исключить - надо либо делать popup, либо как я - сделал полноценную ссылку на redirect.php
4. Библиотеку надо отредактировать так, что-бы вместо констант использовались переменные из сессии (Ключ приложения). В index.php после успешной авторизации надо вставить редирект обратно в приложение, таким образом библиотека будет независимым модулем.
5. После успешного получения ключа доступа и редиректа обратно в приложение, мы сохраняем ключ доступа и используем теперь только его.  
    

  

При переходе со старой авторизации на новую **формат** данных к счастью не поменялся. Для получения своей ленты сообщений теперь достаточно кода

```
$connection = new TwitterOAuth($aSyncAccount['consumer_key'], $aSyncAccount['consumer_secret'], $aSyncAccount['access_key'], $aSyncAccount['access_secret']);
$user = $connection->get('account/verify_credentials');
$arrPosts = $connection->get('statuses/user_timeline');
```

  
По теме:  

- [Авторизация на основе Zend Framework](http://framework.zend.com/manual/en/zend.oauth.introduction.html) (Oauth + Crypt компоненты)  
    
- [Длинное описание протокола простым и понятным языком на примере PHP, rutvit, Andy Smith lib](http://habrahabr.ru/blogs/social_networks/77648/)