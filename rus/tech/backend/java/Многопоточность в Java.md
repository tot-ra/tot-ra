среда, 2 апреля 2008 г. в 10:31:35

Потоки внешне это объекты, работающие параллельно с процессором - каждый имеет фиксированную долю процессорного времени и случайным образом запускаемые. При работе потоков, методы третьих объектов могут обрываться, если время потока заканчивается.

Главные методы класса **Thread**:

- yield - отказ от процессорного времени - другие процессы могут работать.
- sleep - спящий поток (в миллисекундах), при этом другие процессы ждут, может быть насильно прерван, поэтому ставится в try-конструкцию
- interrupt - разбудить поток
- join - установление зависимости между потоками.. зависящий поток должен ждать окончания главного

Конкурирующие потоки, работающие с одним ресурсом могут столкнуться с техническими проблемами "разрыва времени" — компьютеры имеют разные реализации управления памятью между (многоядерными)процессором, RAM, регистрами и кэшем (собственно отсюда различие Itanium, Sun, Pentium архитектур..). Для этого есть ключевое слово у метода _synchronized_, который говорит о том что метод выполняется как атомарная операция.

- getPriority, setPriority методы позволяют установить и прочитать важность потока относительно остальных
- setDaemon, isDaemon - методы создающие демонов как потоки, при закрытии которых программа остановит обычные потоки

Особенность synchronized ещё и в том, что фигурными скобками можно отметить блок который должен быть атомарным (а не только отдельный метод). По умолчанию обычный статичный метод _main_, так же считается потоком.

- [Java Threads](http://www.cs.usfca.edu/%7Eparrt/course/601/lectures/threads.html)
- [Multithreading strategies in php](http://www.alternateinterior.com/2007/05/multi-threading-strategies-in-php.html)
- Есть ли [многопоточность в php](http://anarhist.name/scripts/est-li-mnogopotochnost-v-php/)?